{"filter":false,"title":"simple_html_dom.php","tooltip":"/public/simple_html_dom.php","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":1741,"column":2},"action":"insert","lines":["<?php","/**"," * Website: http://sourceforge.net/projects/simplehtmldom/"," * Additional projects that may be used: http://sourceforge.net/projects/debugobject/"," * Acknowledge: Jose Solorzano (https://sourceforge.net/projects/php-html/)"," * Contributions by:"," *\t Yousuke Kumakura (Attribute filters)"," *\t Vadim Voituk (Negative indexes supports of \"find\" method)"," *\t Antcs (Constructor with automatically load contents either text or file/url)"," *"," * all affected sections have comments starting with \"PaperG\""," *"," * Paperg - Added case insensitive testing of the value of the selector."," * Paperg - Added tag_start for the starting index of tags - NOTE: This works but not accurately."," *  This tag_start gets counted AFTER \\r\\n have been crushed out, and after the remove_noice calls so it will not reflect the REAL position of the tag in the source,"," *  it will almost always be smaller by some amount."," *  We use this to determine how far into the file the tag in question is.  This \"percentage will never be accurate as the $dom->size is the \"real\" number of bytes the dom was created from."," *  but for most purposes, it's a really good estimation."," * Paperg - Added the forceTagsClosed to the dom constructor.  Forcing tags closed is great for malformed html, but it CAN lead to parsing errors."," * Allow the user to tell us how much they trust the html."," * Paperg add the text and plaintext to the selectors for the find syntax.  plaintext implies text in the innertext of a node.  text implies that the tag is a text node."," * This allows for us to find tags based on the text they contain."," * Create find_ancestor_tag to see if a tag is - at any level - inside of another specific tag."," * Paperg: added parse_charset so that we know about the character set of the source document."," *  NOTE:  If the user's system has a routine called get_last_retrieve_url_contents_content_type availalbe, we will assume it's returning the content-type header from the"," *  last transfer or curl_exec, and we will parse that and use it in preference to any other method of charset detection."," *"," * Found infinite loop in the case of broken html in restore_noise.  Rewrote to protect from that."," * PaperG (John Schlick) Added get_display_size for \"IMG\" tags."," *"," * Licensed under The MIT License"," * Redistributions of files must retain the above copyright notice."," *"," * @author S.C. Chen <me578022@gmail.com>"," * @author John Schlick"," * @author Rus Carroll"," * @version 1.5 ($Rev: 210 $)"," * @package PlaceLocalInclude"," * @subpackage simple_html_dom"," */","","/**"," * All of the Defines for the classes below."," * @author S.C. Chen <me578022@gmail.com>"," */","define('HDOM_TYPE_ELEMENT', 1);","define('HDOM_TYPE_COMMENT', 2);","define('HDOM_TYPE_TEXT',\t3);","define('HDOM_TYPE_ENDTAG',  4);","define('HDOM_TYPE_ROOT',\t5);","define('HDOM_TYPE_UNKNOWN', 6);","define('HDOM_QUOTE_DOUBLE', 0);","define('HDOM_QUOTE_SINGLE', 1);","define('HDOM_QUOTE_NO',\t 3);","define('HDOM_INFO_BEGIN',   0);","define('HDOM_INFO_END',\t 1);","define('HDOM_INFO_QUOTE',   2);","define('HDOM_INFO_SPACE',   3);","define('HDOM_INFO_TEXT',\t4);","define('HDOM_INFO_INNER',   5);","define('HDOM_INFO_OUTER',   6);","define('HDOM_INFO_ENDSPACE',7);","define('DEFAULT_TARGET_CHARSET', 'UTF-8');","define('DEFAULT_BR_TEXT', \"\\r\\n\");","define('DEFAULT_SPAN_TEXT', \" \");","define('MAX_FILE_SIZE', 600000);","// helper functions","// -----------------------------------------------------------------------------","// get html dom from file","// $maxlen is defined in the code as PHP_STREAM_COPY_ALL which is defined as -1.","function file_get_html($url, $use_include_path = false, $context=null, $offset = -1, $maxLen=-1, $lowercase = true, $forceTagsClosed=true, $target_charset = DEFAULT_TARGET_CHARSET, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT, $defaultSpanText=DEFAULT_SPAN_TEXT)","{","\t// We DO force the tags to be terminated.","\t$dom = new simple_html_dom(null, $lowercase, $forceTagsClosed, $target_charset, $stripRN, $defaultBRText, $defaultSpanText);","\t// For sourceforge users: uncomment the next line and comment the retreive_url_contents line 2 lines down if it is not already done.","\t$contents = file_get_contents($url, $use_include_path, $context, $offset);","\t// Paperg - use our own mechanism for getting the contents as we want to control the timeout.","\t//$contents = retrieve_url_contents($url);","\tif (empty($contents) || strlen($contents) > MAX_FILE_SIZE)","\t{","\t\treturn false;","\t}","\t// The second parameter can force the selectors to all be lowercase.","\t$dom->load($contents, $lowercase, $stripRN);","\treturn $dom;","}","","// get html dom from string","function str_get_html($str, $lowercase=true, $forceTagsClosed=true, $target_charset = DEFAULT_TARGET_CHARSET, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT, $defaultSpanText=DEFAULT_SPAN_TEXT)","{","\t$dom = new simple_html_dom(null, $lowercase, $forceTagsClosed, $target_charset, $stripRN, $defaultBRText, $defaultSpanText);","\tif (empty($str) || strlen($str) > MAX_FILE_SIZE)","\t{","\t\t$dom->clear();","\t\treturn false;","\t}","\t$dom->load($str, $lowercase, $stripRN);","\treturn $dom;","}","","// dump html dom tree","function dump_html_tree($node, $show_attr=true, $deep=0)","{","\t$node->dump($node);","}","","","/**"," * simple html dom node"," * PaperG - added ability for \"find\" routine to lowercase the value of the selector."," * PaperG - added $tag_start to track the start position of the tag in the total byte index"," *"," * @package PlaceLocalInclude"," */","class simple_html_dom_node","{","\tpublic $nodetype = HDOM_TYPE_TEXT;","\tpublic $tag = 'text';","\tpublic $attr = array();","\tpublic $children = array();","\tpublic $nodes = array();","\tpublic $parent = null;","\t// The \"info\" array - see HDOM_INFO_... for what each element contains.","\tpublic $_ = array();","\tpublic $tag_start = 0;","\tprivate $dom = null;","","\tfunction __construct($dom)","\t{","\t\t$this->dom = $dom;","\t\t$dom->nodes[] = $this;","\t}","","\tfunction __destruct()","\t{","\t\t$this->clear();","\t}","","\tfunction __toString()","\t{","\t\treturn $this->outertext();","\t}","","\t// clean up memory due to php5 circular references memory leak...","\tfunction clear()","\t{","\t\t$this->dom = null;","\t\t$this->nodes = null;","\t\t$this->parent = null;","\t\t$this->children = null;","\t}","","\t// dump node's tree","\tfunction dump($show_attr=true, $deep=0)","\t{","\t\t$lead = str_repeat('\t', $deep);","","\t\techo $lead.$this->tag;","\t\tif ($show_attr && count($this->attr)>0)","\t\t{","\t\t\techo '(';","\t\t\tforeach ($this->attr as $k=>$v)","\t\t\t\techo \"[$k]=>\\\"\".$this->$k.'\", ';","\t\t\techo ')';","\t\t}","\t\techo \"\\n\";","","\t\tif ($this->nodes)","\t\t{","\t\t\tforeach ($this->nodes as $c)","\t\t\t{","\t\t\t\t$c->dump($show_attr, $deep+1);","\t\t\t}","\t\t}","\t}","","","\t// Debugging function to dump a single dom node with a bunch of information about it.","\tfunction dump_node($echo=true)","\t{","","\t\t$string = $this->tag;","\t\tif (count($this->attr)>0)","\t\t{","\t\t\t$string .= '(';","\t\t\tforeach ($this->attr as $k=>$v)","\t\t\t{","\t\t\t\t$string .= \"[$k]=>\\\"\".$this->$k.'\", ';","\t\t\t}","\t\t\t$string .= ')';","\t\t}","\t\tif (count($this->_)>0)","\t\t{","\t\t\t$string .= ' $_ (';","\t\t\tforeach ($this->_ as $k=>$v)","\t\t\t{","\t\t\t\tif (is_array($v))","\t\t\t\t{","\t\t\t\t\t$string .= \"[$k]=>(\";","\t\t\t\t\tforeach ($v as $k2=>$v2)","\t\t\t\t\t{","\t\t\t\t\t\t$string .= \"[$k2]=>\\\"\".$v2.'\", ';","\t\t\t\t\t}","\t\t\t\t\t$string .= \")\";","\t\t\t\t} else {","\t\t\t\t\t$string .= \"[$k]=>\\\"\".$v.'\", ';","\t\t\t\t}","\t\t\t}","\t\t\t$string .= \")\";","\t\t}","","\t\tif (isset($this->text))","\t\t{","\t\t\t$string .= \" text: (\" . $this->text . \")\";","\t\t}","","\t\t$string .= \" HDOM_INNER_INFO: '\";","\t\tif (isset($node->_[HDOM_INFO_INNER]))","\t\t{","\t\t\t$string .= $node->_[HDOM_INFO_INNER] . \"'\";","\t\t}","\t\telse","\t\t{","\t\t\t$string .= ' NULL ';","\t\t}","","\t\t$string .= \" children: \" . count($this->children);","\t\t$string .= \" nodes: \" . count($this->nodes);","\t\t$string .= \" tag_start: \" . $this->tag_start;","\t\t$string .= \"\\n\";","","\t\tif ($echo)","\t\t{","\t\t\techo $string;","\t\t\treturn;","\t\t}","\t\telse","\t\t{","\t\t\treturn $string;","\t\t}","\t}","","\t// returns the parent of node","\t// If a node is passed in, it will reset the parent of the current node to that one.","\tfunction parent($parent=null)","\t{","\t\t// I am SURE that this doesn't work properly.","\t\t// It fails to unset the current node from it's current parents nodes or children list first.","\t\tif ($parent !== null)","\t\t{","\t\t\t$this->parent = $parent;","\t\t\t$this->parent->nodes[] = $this;","\t\t\t$this->parent->children[] = $this;","\t\t}","","\t\treturn $this->parent;","\t}","","\t// verify that node has children","\tfunction has_child()","\t{","\t\treturn !empty($this->children);","\t}","","\t// returns children of node","\tfunction children($idx=-1)","\t{","\t\tif ($idx===-1)","\t\t{","\t\t\treturn $this->children;","\t\t}","\t\tif (isset($this->children[$idx]))","\t\t{","\t\t\treturn $this->children[$idx];","\t\t}","\t\treturn null;","\t}","","\t// returns the first child of node","\tfunction first_child()","\t{","\t\tif (count($this->children)>0)","\t\t{","\t\t\treturn $this->children[0];","\t\t}","\t\treturn null;","\t}","","\t// returns the last child of node","\tfunction last_child()","\t{","\t\tif (($count=count($this->children))>0)","\t\t{","\t\t\treturn $this->children[$count-1];","\t\t}","\t\treturn null;","\t}","","\t// returns the next sibling of node","\tfunction next_sibling()","\t{","\t\tif ($this->parent===null)","\t\t{","\t\t\treturn null;","\t\t}","","\t\t$idx = 0;","\t\t$count = count($this->parent->children);","\t\twhile ($idx<$count && $this!==$this->parent->children[$idx])","\t\t{","\t\t\t++$idx;","\t\t}","\t\tif (++$idx>=$count)","\t\t{","\t\t\treturn null;","\t\t}","\t\treturn $this->parent->children[$idx];","\t}","","\t// returns the previous sibling of node","\tfunction prev_sibling()","\t{","\t\tif ($this->parent===null) return null;","\t\t$idx = 0;","\t\t$count = count($this->parent->children);","\t\twhile ($idx<$count && $this!==$this->parent->children[$idx])","\t\t\t++$idx;","\t\tif (--$idx<0) return null;","\t\treturn $this->parent->children[$idx];","\t}","","\t// function to locate a specific ancestor tag in the path to the root.","\tfunction find_ancestor_tag($tag)","\t{","\t\tglobal $debug_object;","\t\tif (is_object($debug_object)) { $debug_object->debug_log_entry(1); }","","\t\t// Start by including ourselves in the comparison.","\t\t$returnDom = $this;","","\t\twhile (!is_null($returnDom))","\t\t{","\t\t\tif (is_object($debug_object)) { $debug_object->debug_log(2, \"Current tag is: \" . $returnDom->tag); }","","\t\t\tif ($returnDom->tag == $tag)","\t\t\t{","\t\t\t\tbreak;","\t\t\t}","\t\t\t$returnDom = $returnDom->parent;","\t\t}","\t\treturn $returnDom;","\t}","","\t// get dom node's inner html","\tfunction innertext()","\t{","\t\tif (isset($this->_[HDOM_INFO_INNER])) return $this->_[HDOM_INFO_INNER];","\t\tif (isset($this->_[HDOM_INFO_TEXT])) return $this->dom->restore_noise($this->_[HDOM_INFO_TEXT]);","","\t\t$ret = '';","\t\tforeach ($this->nodes as $n)","\t\t\t$ret .= $n->outertext();","\t\treturn $ret;","\t}","","\t// get dom node's outer text (with tag)","\tfunction outertext()","\t{","\t\tglobal $debug_object;","\t\tif (is_object($debug_object))","\t\t{","\t\t\t$text = '';","\t\t\tif ($this->tag == 'text')","\t\t\t{","\t\t\t\tif (!empty($this->text))","\t\t\t\t{","\t\t\t\t\t$text = \" with text: \" . $this->text;","\t\t\t\t}","\t\t\t}","\t\t\t$debug_object->debug_log(1, 'Innertext of tag: ' . $this->tag . $text);","\t\t}","","\t\tif ($this->tag==='root') return $this->innertext();","","\t\t// trigger callback","\t\tif ($this->dom && $this->dom->callback!==null)","\t\t{","\t\t\tcall_user_func_array($this->dom->callback, array($this));","\t\t}","","\t\tif (isset($this->_[HDOM_INFO_OUTER])) return $this->_[HDOM_INFO_OUTER];","\t\tif (isset($this->_[HDOM_INFO_TEXT])) return $this->dom->restore_noise($this->_[HDOM_INFO_TEXT]);","","\t\t// render begin tag","\t\tif ($this->dom && $this->dom->nodes[$this->_[HDOM_INFO_BEGIN]])","\t\t{","\t\t\t$ret = $this->dom->nodes[$this->_[HDOM_INFO_BEGIN]]->makeup();","\t\t} else {","\t\t\t$ret = \"\";","\t\t}","","\t\t// render inner text","\t\tif (isset($this->_[HDOM_INFO_INNER]))","\t\t{","\t\t\t// If it's a br tag...  don't return the HDOM_INNER_INFO that we may or may not have added.","\t\t\tif ($this->tag != \"br\")","\t\t\t{","\t\t\t\t$ret .= $this->_[HDOM_INFO_INNER];","\t\t\t}","\t\t} else {","\t\t\tif ($this->nodes)","\t\t\t{","\t\t\t\tforeach ($this->nodes as $n)","\t\t\t\t{","\t\t\t\t\t$ret .= $this->convert_text($n->outertext());","\t\t\t\t}","\t\t\t}","\t\t}","","\t\t// render end tag","\t\tif (isset($this->_[HDOM_INFO_END]) && $this->_[HDOM_INFO_END]!=0)","\t\t\t$ret .= '</'.$this->tag.'>';","\t\treturn $ret;","\t}","","\t// get dom node's plain text","\tfunction text()","\t{","\t\tif (isset($this->_[HDOM_INFO_INNER])) return $this->_[HDOM_INFO_INNER];","\t\tswitch ($this->nodetype)","\t\t{","\t\t\tcase HDOM_TYPE_TEXT: return $this->dom->restore_noise($this->_[HDOM_INFO_TEXT]);","\t\t\tcase HDOM_TYPE_COMMENT: return '';","\t\t\tcase HDOM_TYPE_UNKNOWN: return '';","\t\t}","\t\tif (strcasecmp($this->tag, 'script')===0) return '';","\t\tif (strcasecmp($this->tag, 'style')===0) return '';","","\t\t$ret = '';","\t\t// In rare cases, (always node type 1 or HDOM_TYPE_ELEMENT - observed for some span tags, and some p tags) $this->nodes is set to NULL.","\t\t// NOTE: This indicates that there is a problem where it's set to NULL without a clear happening.","\t\t// WHY is this happening?","\t\tif (!is_null($this->nodes))","\t\t{","\t\t\tforeach ($this->nodes as $n)","\t\t\t{","\t\t\t\t$ret .= $this->convert_text($n->text());","\t\t\t}","","\t\t\t// If this node is a span... add a space at the end of it so multiple spans don't run into each other.  This is plaintext after all.","\t\t\tif ($this->tag == \"span\")","\t\t\t{","\t\t\t\t$ret .= $this->dom->default_span_text;","\t\t\t}","","","\t\t}","\t\treturn $ret;","\t}","","\tfunction xmltext()","\t{","\t\t$ret = $this->innertext();","\t\t$ret = str_ireplace('<![CDATA[', '', $ret);","\t\t$ret = str_replace(']]>', '', $ret);","\t\treturn $ret;","\t}","","\t// build node's text with tag","\tfunction makeup()","\t{","\t\t// text, comment, unknown","\t\tif (isset($this->_[HDOM_INFO_TEXT])) return $this->dom->restore_noise($this->_[HDOM_INFO_TEXT]);","","\t\t$ret = '<'.$this->tag;","\t\t$i = -1;","","\t\tforeach ($this->attr as $key=>$val)","\t\t{","\t\t\t++$i;","","\t\t\t// skip removed attribute","\t\t\tif ($val===null || $val===false)","\t\t\t\tcontinue;","","\t\t\t$ret .= $this->_[HDOM_INFO_SPACE][$i][0];","\t\t\t//no value attr: nowrap, checked selected...","\t\t\tif ($val===true)","\t\t\t\t$ret .= $key;","\t\t\telse {","\t\t\t\tswitch ($this->_[HDOM_INFO_QUOTE][$i])","\t\t\t\t{","\t\t\t\t\tcase HDOM_QUOTE_DOUBLE: $quote = '\"'; break;","\t\t\t\t\tcase HDOM_QUOTE_SINGLE: $quote = '\\''; break;","\t\t\t\t\tdefault: $quote = '';","\t\t\t\t}","\t\t\t\t$ret .= $key.$this->_[HDOM_INFO_SPACE][$i][1].'='.$this->_[HDOM_INFO_SPACE][$i][2].$quote.$val.$quote;","\t\t\t}","\t\t}","\t\t$ret = $this->dom->restore_noise($ret);","\t\treturn $ret . $this->_[HDOM_INFO_ENDSPACE] . '>';","\t}","","\t// find elements by css selector","\t//PaperG - added ability for find to lowercase the value of the selector.","\tfunction find($selector, $idx=null, $lowercase=false)","\t{","\t\t$selectors = $this->parse_selector($selector);","\t\tif (($count=count($selectors))===0) return array();","\t\t$found_keys = array();","","\t\t// find each selector","\t\tfor ($c=0; $c<$count; ++$c)","\t\t{","\t\t\t// The change on the below line was documented on the sourceforge code tracker id 2788009","\t\t\t// used to be: if (($levle=count($selectors[0]))===0) return array();","\t\t\tif (($levle=count($selectors[$c]))===0) return array();","\t\t\tif (!isset($this->_[HDOM_INFO_BEGIN])) return array();","","\t\t\t$head = array($this->_[HDOM_INFO_BEGIN]=>1);","","\t\t\t// handle descendant selectors, no recursive!","\t\t\tfor ($l=0; $l<$levle; ++$l)","\t\t\t{","\t\t\t\t$ret = array();","\t\t\t\tforeach ($head as $k=>$v)","\t\t\t\t{","\t\t\t\t\t$n = ($k===-1) ? $this->dom->root : $this->dom->nodes[$k];","\t\t\t\t\t//PaperG - Pass this optional parameter on to the seek function.","\t\t\t\t\t$n->seek($selectors[$c][$l], $ret, $lowercase);","\t\t\t\t}","\t\t\t\t$head = $ret;","\t\t\t}","","\t\t\tforeach ($head as $k=>$v)","\t\t\t{","\t\t\t\tif (!isset($found_keys[$k]))","\t\t\t\t{","\t\t\t\t\t$found_keys[$k] = 1;","\t\t\t\t}","\t\t\t}","\t\t}","","\t\t// sort keys","\t\tksort($found_keys);","","\t\t$found = array();","\t\tforeach ($found_keys as $k=>$v)","\t\t\t$found[] = $this->dom->nodes[$k];","","\t\t// return nth-element or array","\t\tif (is_null($idx)) return $found;","\t\telse if ($idx<0) $idx = count($found) + $idx;","\t\treturn (isset($found[$idx])) ? $found[$idx] : null;","\t}","","\t// seek for given conditions","\t// PaperG - added parameter to allow for case insensitive testing of the value of a selector.","\tprotected function seek($selector, &$ret, $lowercase=false)","\t{","\t\tglobal $debug_object;","\t\tif (is_object($debug_object)) { $debug_object->debug_log_entry(1); }","","\t\tlist($tag, $key, $val, $exp, $no_key) = $selector;","","\t\t// xpath index","\t\tif ($tag && $key && is_numeric($key))","\t\t{","\t\t\t$count = 0;","\t\t\tforeach ($this->children as $c)","\t\t\t{","\t\t\t\tif ($tag==='*' || $tag===$c->tag) {","\t\t\t\t\tif (++$count==$key) {","\t\t\t\t\t\t$ret[$c->_[HDOM_INFO_BEGIN]] = 1;","\t\t\t\t\t\treturn;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t\treturn;","\t\t}","","\t\t$end = (!empty($this->_[HDOM_INFO_END])) ? $this->_[HDOM_INFO_END] : 0;","\t\tif ($end==0) {","\t\t\t$parent = $this->parent;","\t\t\twhile (!isset($parent->_[HDOM_INFO_END]) && $parent!==null) {","\t\t\t\t$end -= 1;","\t\t\t\t$parent = $parent->parent;","\t\t\t}","\t\t\t$end += $parent->_[HDOM_INFO_END];","\t\t}","","\t\tfor ($i=$this->_[HDOM_INFO_BEGIN]+1; $i<$end; ++$i) {","\t\t\t$node = $this->dom->nodes[$i];","","\t\t\t$pass = true;","","\t\t\tif ($tag==='*' && !$key) {","\t\t\t\tif (in_array($node, $this->children, true))","\t\t\t\t\t$ret[$i] = 1;","\t\t\t\tcontinue;","\t\t\t}","","\t\t\t// compare tag","\t\t\tif ($tag && $tag!=$node->tag && $tag!=='*') {$pass=false;}","\t\t\t// compare key","\t\t\tif ($pass && $key) {","\t\t\t\tif ($no_key) {","\t\t\t\t\tif (isset($node->attr[$key])) $pass=false;","\t\t\t\t} else {","\t\t\t\t\tif (($key != \"plaintext\") && !isset($node->attr[$key])) $pass=false;","\t\t\t\t}","\t\t\t}","\t\t\t// compare value","\t\t\tif ($pass && $key && $val  && $val!=='*') {","\t\t\t\t// If they have told us that this is a \"plaintext\" search then we want the plaintext of the node - right?","\t\t\t\tif ($key == \"plaintext\") {","\t\t\t\t\t// $node->plaintext actually returns $node->text();","\t\t\t\t\t$nodeKeyValue = $node->text();","\t\t\t\t} else {","\t\t\t\t\t// this is a normal search, we want the value of that attribute of the tag.","\t\t\t\t\t$nodeKeyValue = $node->attr[$key];","\t\t\t\t}","\t\t\t\tif (is_object($debug_object)) {$debug_object->debug_log(2, \"testing node: \" . $node->tag . \" for attribute: \" . $key . $exp . $val . \" where nodes value is: \" . $nodeKeyValue);}","","\t\t\t\t//PaperG - If lowercase is set, do a case insensitive test of the value of the selector.","\t\t\t\tif ($lowercase) {","\t\t\t\t\t$check = $this->match($exp, strtolower($val), strtolower($nodeKeyValue));","\t\t\t\t} else {","\t\t\t\t\t$check = $this->match($exp, $val, $nodeKeyValue);","\t\t\t\t}","\t\t\t\tif (is_object($debug_object)) {$debug_object->debug_log(2, \"after match: \" . ($check ? \"true\" : \"false\"));}","","\t\t\t\t// handle multiple class","\t\t\t\tif (!$check && strcasecmp($key, 'class')===0) {","\t\t\t\t\tforeach (explode(' ',$node->attr[$key]) as $k) {","\t\t\t\t\t\t// Without this, there were cases where leading, trailing, or double spaces lead to our comparing blanks - bad form.","\t\t\t\t\t\tif (!empty($k)) {","\t\t\t\t\t\t\tif ($lowercase) {","\t\t\t\t\t\t\t\t$check = $this->match($exp, strtolower($val), strtolower($k));","\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t$check = $this->match($exp, $val, $k);","\t\t\t\t\t\t\t}","\t\t\t\t\t\t\tif ($check) break;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif (!$check) $pass = false;","\t\t\t}","\t\t\tif ($pass) $ret[$i] = 1;","\t\t\tunset($node);","\t\t}","\t\t// It's passed by reference so this is actually what this function returns.","\t\tif (is_object($debug_object)) {$debug_object->debug_log(1, \"EXIT - ret: \", $ret);}","\t}","","\tprotected function match($exp, $pattern, $value) {","\t\tglobal $debug_object;","\t\tif (is_object($debug_object)) {$debug_object->debug_log_entry(1);}","","\t\tswitch ($exp) {","\t\t\tcase '=':","\t\t\t\treturn ($value===$pattern);","\t\t\tcase '!=':","\t\t\t\treturn ($value!==$pattern);","\t\t\tcase '^=':","\t\t\t\treturn preg_match(\"/^\".preg_quote($pattern,'/').\"/\", $value);","\t\t\tcase '$=':","\t\t\t\treturn preg_match(\"/\".preg_quote($pattern,'/').\"$/\", $value);","\t\t\tcase '*=':","\t\t\t\tif ($pattern[0]=='/') {","\t\t\t\t\treturn preg_match($pattern, $value);","\t\t\t\t}","\t\t\t\treturn preg_match(\"/\".$pattern.\"/i\", $value);","\t\t}","\t\treturn false;","\t}","","\tprotected function parse_selector($selector_string) {","\t\tglobal $debug_object;","\t\tif (is_object($debug_object)) {$debug_object->debug_log_entry(1);}","","\t\t// pattern of CSS selectors, modified from mootools","\t\t// Paperg: Add the colon to the attrbute, so that it properly finds <tag attr:ibute=\"something\" > like google does.","\t\t// Note: if you try to look at this attribute, yo MUST use getAttribute since $dom->x:y will fail the php syntax check.","// Notice the \\[ starting the attbute?  and the @? following?  This implies that an attribute can begin with an @ sign that is not captured.","// This implies that an html attribute specifier may start with an @ sign that is NOT captured by the expression.","// farther study is required to determine of this should be documented or removed.","//\t\t$pattern = \"/([\\w-:\\*]*)(?:\\#([\\w-]+)|\\.([\\w-]+))?(?:\\[@?(!?[\\w-]+)(?:([!*^$]?=)[\\\"']?(.*?)[\\\"']?)?\\])?([\\/, ]+)/is\";","\t\t$pattern = \"/([\\w-:\\*]*)(?:\\#([\\w-]+)|\\.([\\w-]+))?(?:\\[@?(!?[\\w-:]+)(?:([!*^$]?=)[\\\"']?(.*?)[\\\"']?)?\\])?([\\/, ]+)/is\";","\t\tpreg_match_all($pattern, trim($selector_string).' ', $matches, PREG_SET_ORDER);","\t\tif (is_object($debug_object)) {$debug_object->debug_log(2, \"Matches Array: \", $matches);}","","\t\t$selectors = array();","\t\t$result = array();","\t\t//print_r($matches);","","\t\tforeach ($matches as $m) {","\t\t\t$m[0] = trim($m[0]);","\t\t\tif ($m[0]==='' || $m[0]==='/' || $m[0]==='//') continue;","\t\t\t// for browser generated xpath","\t\t\tif ($m[1]==='tbody') continue;","","\t\t\tlist($tag, $key, $val, $exp, $no_key) = array($m[1], null, null, '=', false);","\t\t\tif (!empty($m[2])) {$key='id'; $val=$m[2];}","\t\t\tif (!empty($m[3])) {$key='class'; $val=$m[3];}","\t\t\tif (!empty($m[4])) {$key=$m[4];}","\t\t\tif (!empty($m[5])) {$exp=$m[5];}","\t\t\tif (!empty($m[6])) {$val=$m[6];}","","\t\t\t// convert to lowercase","\t\t\tif ($this->dom->lowercase) {$tag=strtolower($tag); $key=strtolower($key);}","\t\t\t//elements that do NOT have the specified attribute","\t\t\tif (isset($key[0]) && $key[0]==='!') {$key=substr($key, 1); $no_key=true;}","","\t\t\t$result[] = array($tag, $key, $val, $exp, $no_key);","\t\t\tif (trim($m[7])===',') {","\t\t\t\t$selectors[] = $result;","\t\t\t\t$result = array();","\t\t\t}","\t\t}","\t\tif (count($result)>0)","\t\t\t$selectors[] = $result;","\t\treturn $selectors;","\t}","","\tfunction __get($name)","\t{","\t\tif (isset($this->attr[$name]))","\t\t{","\t\t\treturn $this->convert_text($this->attr[$name]);","\t\t}","\t\tswitch ($name)","\t\t{","\t\t\tcase 'outertext': return $this->outertext();","\t\t\tcase 'innertext': return $this->innertext();","\t\t\tcase 'plaintext': return $this->text();","\t\t\tcase 'xmltext': return $this->xmltext();","\t\t\tdefault: return array_key_exists($name, $this->attr);","\t\t}","\t}","","\tfunction __set($name, $value)","\t{","\t\tglobal $debug_object;","\t\tif (is_object($debug_object)) {$debug_object->debug_log_entry(1);}","","\t\tswitch ($name)","\t\t{","\t\t\tcase 'outertext': return $this->_[HDOM_INFO_OUTER] = $value;","\t\t\tcase 'innertext':","\t\t\t\tif (isset($this->_[HDOM_INFO_TEXT])) return $this->_[HDOM_INFO_TEXT] = $value;","\t\t\t\treturn $this->_[HDOM_INFO_INNER] = $value;","\t\t}","\t\tif (!isset($this->attr[$name]))","\t\t{","\t\t\t$this->_[HDOM_INFO_SPACE][] = array(' ', '', '');","\t\t\t$this->_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_DOUBLE;","\t\t}","\t\t$this->attr[$name] = $value;","\t}","","\tfunction __isset($name)","\t{","\t\tswitch ($name)","\t\t{","\t\t\tcase 'outertext': return true;","\t\t\tcase 'innertext': return true;","\t\t\tcase 'plaintext': return true;","\t\t}","\t\t//no value attr: nowrap, checked selected...","\t\treturn (array_key_exists($name, $this->attr)) ? true : isset($this->attr[$name]);","\t}","","\tfunction __unset($name) {","\t\tif (isset($this->attr[$name]))","\t\t\tunset($this->attr[$name]);","\t}","","\t// PaperG - Function to convert the text from one character set to another if the two sets are not the same.","\tfunction convert_text($text)","\t{","\t\tglobal $debug_object;","\t\tif (is_object($debug_object)) {$debug_object->debug_log_entry(1);}","","\t\t$converted_text = $text;","","\t\t$sourceCharset = \"\";","\t\t$targetCharset = \"\";","","\t\tif ($this->dom)","\t\t{","\t\t\t$sourceCharset = strtoupper($this->dom->_charset);","\t\t\t$targetCharset = strtoupper($this->dom->_target_charset);","\t\t}","\t\tif (is_object($debug_object)) {$debug_object->debug_log(3, \"source charset: \" . $sourceCharset . \" target charaset: \" . $targetCharset);}","","\t\tif (!empty($sourceCharset) && !empty($targetCharset) && (strcasecmp($sourceCharset, $targetCharset) != 0))","\t\t{","\t\t\t// Check if the reported encoding could have been incorrect and the text is actually already UTF-8","\t\t\tif ((strcasecmp($targetCharset, 'UTF-8') == 0) && ($this->is_utf8($text)))","\t\t\t{","\t\t\t\t$converted_text = $text;","\t\t\t}","\t\t\telse","\t\t\t{","\t\t\t\t$converted_text = iconv($sourceCharset, $targetCharset, $text);","\t\t\t}","\t\t}","","\t\t// Lets make sure that we don't have that silly BOM issue with any of the utf-8 text we output.","\t\tif ($targetCharset == 'UTF-8')","\t\t{","\t\t\tif (substr($converted_text, 0, 3) == \"\\xef\\xbb\\xbf\")","\t\t\t{","\t\t\t\t$converted_text = substr($converted_text, 3);","\t\t\t}","\t\t\tif (substr($converted_text, -3) == \"\\xef\\xbb\\xbf\")","\t\t\t{","\t\t\t\t$converted_text = substr($converted_text, 0, -3);","\t\t\t}","\t\t}","","\t\treturn $converted_text;","\t}","","\t/**","\t* Returns true if $string is valid UTF-8 and false otherwise.","\t*","\t* @param mixed $str String to be tested","\t* @return boolean","\t*/","\tstatic function is_utf8($str)","\t{","\t\t$c=0; $b=0;","\t\t$bits=0;","\t\t$len=strlen($str);","\t\tfor($i=0; $i<$len; $i++)","\t\t{","\t\t\t$c=ord($str[$i]);","\t\t\tif($c > 128)","\t\t\t{","\t\t\t\tif(($c >= 254)) return false;","\t\t\t\telseif($c >= 252) $bits=6;","\t\t\t\telseif($c >= 248) $bits=5;","\t\t\t\telseif($c >= 240) $bits=4;","\t\t\t\telseif($c >= 224) $bits=3;","\t\t\t\telseif($c >= 192) $bits=2;","\t\t\t\telse return false;","\t\t\t\tif(($i+$bits) > $len) return false;","\t\t\t\twhile($bits > 1)","\t\t\t\t{","\t\t\t\t\t$i++;","\t\t\t\t\t$b=ord($str[$i]);","\t\t\t\t\tif($b < 128 || $b > 191) return false;","\t\t\t\t\t$bits--;","\t\t\t\t}","\t\t\t}","\t\t}","\t\treturn true;","\t}","\t/*","\tfunction is_utf8($string)","\t{","\t\t//this is buggy","\t\treturn (utf8_encode(utf8_decode($string)) == $string);","\t}","\t*/","","\t/**","\t * Function to try a few tricks to determine the displayed size of an img on the page.","\t * NOTE: This will ONLY work on an IMG tag. Returns FALSE on all other tag types.","\t *","\t * @author John Schlick","\t * @version April 19 2012","\t * @return array an array containing the 'height' and 'width' of the image on the page or -1 if we can't figure it out.","\t */","\tfunction get_display_size()","\t{","\t\tglobal $debug_object;","","\t\t$width = -1;","\t\t$height = -1;","","\t\tif ($this->tag !== 'img')","\t\t{","\t\t\treturn false;","\t\t}","","\t\t// See if there is aheight or width attribute in the tag itself.","\t\tif (isset($this->attr['width']))","\t\t{","\t\t\t$width = $this->attr['width'];","\t\t}","","\t\tif (isset($this->attr['height']))","\t\t{","\t\t\t$height = $this->attr['height'];","\t\t}","","\t\t// Now look for an inline style.","\t\tif (isset($this->attr['style']))","\t\t{","\t\t\t// Thanks to user gnarf from stackoverflow for this regular expression.","\t\t\t$attributes = array();","\t\t\tpreg_match_all(\"/([\\w-]+)\\s*:\\s*([^;]+)\\s*;?/\", $this->attr['style'], $matches, PREG_SET_ORDER);","\t\t\tforeach ($matches as $match) {","\t\t\t  $attributes[$match[1]] = $match[2];","\t\t\t}","","\t\t\t// If there is a width in the style attributes:","\t\t\tif (isset($attributes['width']) && $width == -1)","\t\t\t{","\t\t\t\t// check that the last two characters are px (pixels)","\t\t\t\tif (strtolower(substr($attributes['width'], -2)) == 'px')","\t\t\t\t{","\t\t\t\t\t$proposed_width = substr($attributes['width'], 0, -2);","\t\t\t\t\t// Now make sure that it's an integer and not something stupid.","\t\t\t\t\tif (filter_var($proposed_width, FILTER_VALIDATE_INT))","\t\t\t\t\t{","\t\t\t\t\t\t$width = $proposed_width;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","","\t\t\t// If there is a width in the style attributes:","\t\t\tif (isset($attributes['height']) && $height == -1)","\t\t\t{","\t\t\t\t// check that the last two characters are px (pixels)","\t\t\t\tif (strtolower(substr($attributes['height'], -2)) == 'px')","\t\t\t\t{","\t\t\t\t\t$proposed_height = substr($attributes['height'], 0, -2);","\t\t\t\t\t// Now make sure that it's an integer and not something stupid.","\t\t\t\t\tif (filter_var($proposed_height, FILTER_VALIDATE_INT))","\t\t\t\t\t{","\t\t\t\t\t\t$height = $proposed_height;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","","\t\t}","","\t\t// Future enhancement:","\t\t// Look in the tag to see if there is a class or id specified that has a height or width attribute to it.","","\t\t// Far future enhancement","\t\t// Look at all the parent tags of this image to see if they specify a class or id that has an img selector that specifies a height or width","\t\t// Note that in this case, the class or id will have the img subselector for it to apply to the image.","","\t\t// ridiculously far future development","\t\t// If the class or id is specified in a SEPARATE css file thats not on the page, go get it and do what we were just doing for the ones on the page.","","\t\t$result = array('height' => $height,","\t\t\t\t\t\t'width' => $width);","\t\treturn $result;","\t}","","\t// camel naming conventions","\tfunction getAllAttributes() {return $this->attr;}","\tfunction getAttribute($name) {return $this->__get($name);}","\tfunction setAttribute($name, $value) {$this->__set($name, $value);}","\tfunction hasAttribute($name) {return $this->__isset($name);}","\tfunction removeAttribute($name) {$this->__set($name, null);}","\tfunction getElementById($id) {return $this->find(\"#$id\", 0);}","\tfunction getElementsById($id, $idx=null) {return $this->find(\"#$id\", $idx);}","\tfunction getElementByTagName($name) {return $this->find($name, 0);}","\tfunction getElementsByTagName($name, $idx=null) {return $this->find($name, $idx);}","\tfunction parentNode() {return $this->parent();}","\tfunction childNodes($idx=-1) {return $this->children($idx);}","\tfunction firstChild() {return $this->first_child();}","\tfunction lastChild() {return $this->last_child();}","\tfunction nextSibling() {return $this->next_sibling();}","\tfunction previousSibling() {return $this->prev_sibling();}","\tfunction hasChildNodes() {return $this->has_child();}","\tfunction nodeName() {return $this->tag;}","\tfunction appendChild($node) {$node->parent($this); return $node;}","","}","","/**"," * simple html dom parser"," * Paperg - in the find routine: allow us to specify that we want case insensitive testing of the value of the selector."," * Paperg - change $size from protected to public so we can easily access it"," * Paperg - added ForceTagsClosed in the constructor which tells us whether we trust the html or not.  Default is to NOT trust it."," *"," * @package PlaceLocalInclude"," */","class simple_html_dom","{","\tpublic $root = null;","\tpublic $nodes = array();","\tpublic $callback = null;","\tpublic $lowercase = false;","\t// Used to keep track of how large the text was when we started.","\tpublic $original_size;","\tpublic $size;","\tprotected $pos;","\tprotected $doc;","\tprotected $char;","\tprotected $cursor;","\tprotected $parent;","\tprotected $noise = array();","\tprotected $token_blank = \" \\t\\r\\n\";","\tprotected $token_equal = ' =/>';","\tprotected $token_slash = \" />\\r\\n\\t\";","\tprotected $token_attr = ' >';","\t// Note that this is referenced by a child node, and so it needs to be public for that node to see this information.","\tpublic $_charset = '';","\tpublic $_target_charset = '';","\tprotected $default_br_text = \"\";","\tpublic $default_span_text = \"\";","","\t// use isset instead of in_array, performance boost about 30%...","\tprotected $self_closing_tags = array('img'=>1, 'br'=>1, 'input'=>1, 'meta'=>1, 'link'=>1, 'hr'=>1, 'base'=>1, 'embed'=>1, 'spacer'=>1);","\tprotected $block_tags = array('root'=>1, 'body'=>1, 'form'=>1, 'div'=>1, 'span'=>1, 'table'=>1);","\t// Known sourceforge issue #2977341","\t// B tags that are not closed cause us to return everything to the end of the document.","\tprotected $optional_closing_tags = array(","\t\t'tr'=>array('tr'=>1, 'td'=>1, 'th'=>1),","\t\t'th'=>array('th'=>1),","\t\t'td'=>array('td'=>1),","\t\t'li'=>array('li'=>1),","\t\t'dt'=>array('dt'=>1, 'dd'=>1),","\t\t'dd'=>array('dd'=>1, 'dt'=>1),","\t\t'dl'=>array('dd'=>1, 'dt'=>1),","\t\t'p'=>array('p'=>1),","\t\t'nobr'=>array('nobr'=>1),","\t\t'b'=>array('b'=>1),","\t\t'option'=>array('option'=>1),","\t);","","\tfunction __construct($str=null, $lowercase=true, $forceTagsClosed=true, $target_charset=DEFAULT_TARGET_CHARSET, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT, $defaultSpanText=DEFAULT_SPAN_TEXT)","\t{","\t\tif ($str)","\t\t{","\t\t\tif (preg_match(\"/^http:\\/\\//i\",$str) || is_file($str))","\t\t\t{","\t\t\t\t$this->load_file($str);","\t\t\t}","\t\t\telse","\t\t\t{","\t\t\t\t$this->load($str, $lowercase, $stripRN, $defaultBRText, $defaultSpanText);","\t\t\t}","\t\t}","\t\t// Forcing tags to be closed implies that we don't trust the html, but it can lead to parsing errors if we SHOULD trust the html.","\t\tif (!$forceTagsClosed) {","\t\t\t$this->optional_closing_array=array();","\t\t}","\t\t$this->_target_charset = $target_charset;","\t}","","\tfunction __destruct()","\t{","\t\t$this->clear();","\t}","","\t// load html from string","\tfunction load($str, $lowercase=true, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT, $defaultSpanText=DEFAULT_SPAN_TEXT)","\t{","\t\tglobal $debug_object;","","\t\t// prepare","\t\t$this->prepare($str, $lowercase, $stripRN, $defaultBRText, $defaultSpanText);","\t\t// strip out cdata","\t\t$this->remove_noise(\"'<!\\[CDATA\\[(.*?)\\]\\]>'is\", true);","\t\t// strip out comments","\t\t$this->remove_noise(\"'<!--(.*?)-->'is\");","\t\t// Per sourceforge http://sourceforge.net/tracker/?func=detail&aid=2949097&group_id=218559&atid=1044037","\t\t// Script tags removal now preceeds style tag removal.","\t\t// strip out <script> tags","\t\t$this->remove_noise(\"'<\\s*script[^>]*[^/]>(.*?)<\\s*/\\s*script\\s*>'is\");","\t\t$this->remove_noise(\"'<\\s*script\\s*>(.*?)<\\s*/\\s*script\\s*>'is\");","\t\t// strip out <style> tags","\t\t$this->remove_noise(\"'<\\s*style[^>]*[^/]>(.*?)<\\s*/\\s*style\\s*>'is\");","\t\t$this->remove_noise(\"'<\\s*style\\s*>(.*?)<\\s*/\\s*style\\s*>'is\");","\t\t// strip out preformatted tags","\t\t$this->remove_noise(\"'<\\s*(?:code)[^>]*>(.*?)<\\s*/\\s*(?:code)\\s*>'is\");","\t\t// strip out server side scripts","\t\t$this->remove_noise(\"'(<\\?)(.*?)(\\?>)'s\", true);","\t\t// strip smarty scripts","\t\t$this->remove_noise(\"'(\\{\\w)(.*?)(\\})'s\", true);","","\t\t// parsing","\t\twhile ($this->parse());","\t\t// end","\t\t$this->root->_[HDOM_INFO_END] = $this->cursor;","\t\t$this->parse_charset();","","\t\t// make load function chainable","\t\treturn $this;","","\t}","","\t// load html from file","\tfunction load_file()","\t{","\t\t$args = func_get_args();","\t\t$this->load(call_user_func_array('file_get_contents', $args), true);","\t\t// Throw an error if we can't properly load the dom.","\t\tif (($error=error_get_last())!==null) {","\t\t\t$this->clear();","\t\t\treturn false;","\t\t}","\t}","","\t// set callback function","\tfunction set_callback($function_name)","\t{","\t\t$this->callback = $function_name;","\t}","","\t// remove callback function","\tfunction remove_callback()","\t{","\t\t$this->callback = null;","\t}","","\t// save dom as string","\tfunction save($filepath='')","\t{","\t\t$ret = $this->root->innertext();","\t\tif ($filepath!=='') file_put_contents($filepath, $ret, LOCK_EX);","\t\treturn $ret;","\t}","","\t// find dom node by css selector","\t// Paperg - allow us to specify that we want case insensitive testing of the value of the selector.","\tfunction find($selector, $idx=null, $lowercase=false)","\t{","\t\treturn $this->root->find($selector, $idx, $lowercase);","\t}","","\t// clean up memory due to php5 circular references memory leak...","\tfunction clear()","\t{","\t\tforeach ($this->nodes as $n) {$n->clear(); $n = null;}","\t\t// This add next line is documented in the sourceforge repository. 2977248 as a fix for ongoing memory leaks that occur even with the use of clear.","\t\tif (isset($this->children)) foreach ($this->children as $n) {$n->clear(); $n = null;}","\t\tif (isset($this->parent)) {$this->parent->clear(); unset($this->parent);}","\t\tif (isset($this->root)) {$this->root->clear(); unset($this->root);}","\t\tunset($this->doc);","\t\tunset($this->noise);","\t}","","\tfunction dump($show_attr=true)","\t{","\t\t$this->root->dump($show_attr);","\t}","","\t// prepare HTML data and init everything","\tprotected function prepare($str, $lowercase=true, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT, $defaultSpanText=DEFAULT_SPAN_TEXT)","\t{","\t\t$this->clear();","","\t\t// set the length of content before we do anything to it.","\t\t$this->size = strlen($str);","\t\t// Save the original size of the html that we got in.  It might be useful to someone.","\t\t$this->original_size = $this->size;","","\t\t//before we save the string as the doc...  strip out the \\r \\n's if we are told to.","\t\tif ($stripRN) {","\t\t\t$str = str_replace(\"\\r\", \" \", $str);","\t\t\t$str = str_replace(\"\\n\", \" \", $str);","","\t\t\t// set the length of content since we have changed it.","\t\t\t$this->size = strlen($str);","\t\t}","","\t\t$this->doc = $str;","\t\t$this->pos = 0;","\t\t$this->cursor = 1;","\t\t$this->noise = array();","\t\t$this->nodes = array();","\t\t$this->lowercase = $lowercase;","\t\t$this->default_br_text = $defaultBRText;","\t\t$this->default_span_text = $defaultSpanText;","\t\t$this->root = new simple_html_dom_node($this);","\t\t$this->root->tag = 'root';","\t\t$this->root->_[HDOM_INFO_BEGIN] = -1;","\t\t$this->root->nodetype = HDOM_TYPE_ROOT;","\t\t$this->parent = $this->root;","\t\tif ($this->size>0) $this->char = $this->doc[0];","\t}","","\t// parse html content","\tprotected function parse()","\t{","\t\tif (($s = $this->copy_until_char('<'))==='')","\t\t{","\t\t\treturn $this->read_tag();","\t\t}","","\t\t// text","\t\t$node = new simple_html_dom_node($this);","\t\t++$this->cursor;","\t\t$node->_[HDOM_INFO_TEXT] = $s;","\t\t$this->link_nodes($node, false);","\t\treturn true;","\t}","","\t// PAPERG - dkchou - added this to try to identify the character set of the page we have just parsed so we know better how to spit it out later.","\t// NOTE:  IF you provide a routine called get_last_retrieve_url_contents_content_type which returns the CURLINFO_CONTENT_TYPE from the last curl_exec","\t// (or the content_type header from the last transfer), we will parse THAT, and if a charset is specified, we will use it over any other mechanism.","\tprotected function parse_charset()","\t{","\t\tglobal $debug_object;","","\t\t$charset = null;","","\t\tif (function_exists('get_last_retrieve_url_contents_content_type'))","\t\t{","\t\t\t$contentTypeHeader = get_last_retrieve_url_contents_content_type();","\t\t\t$success = preg_match('/charset=(.+)/', $contentTypeHeader, $matches);","\t\t\tif ($success)","\t\t\t{","\t\t\t\t$charset = $matches[1];","\t\t\t\tif (is_object($debug_object)) {$debug_object->debug_log(2, 'header content-type found charset of: ' . $charset);}","\t\t\t}","","\t\t}","","\t\tif (empty($charset))","\t\t{","\t\t\t$el = $this->root->find('meta[http-equiv=Content-Type]',0, true);","\t\t\tif (!empty($el))","\t\t\t{","\t\t\t\t$fullvalue = $el->content;","\t\t\t\tif (is_object($debug_object)) {$debug_object->debug_log(2, 'meta content-type tag found' . $fullvalue);}","","\t\t\t\tif (!empty($fullvalue))","\t\t\t\t{","\t\t\t\t\t$success = preg_match('/charset=(.+)/i', $fullvalue, $matches);","\t\t\t\t\tif ($success)","\t\t\t\t\t{","\t\t\t\t\t\t$charset = $matches[1];","\t\t\t\t\t}","\t\t\t\t\telse","\t\t\t\t\t{","\t\t\t\t\t\t// If there is a meta tag, and they don't specify the character set, research says that it's typically ISO-8859-1","\t\t\t\t\t\tif (is_object($debug_object)) {$debug_object->debug_log(2, 'meta content-type tag couldn\\'t be parsed. using iso-8859 default.');}","\t\t\t\t\t\t$charset = 'ISO-8859-1';","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","","\t\t// If we couldn't find a charset above, then lets try to detect one based on the text we got...","\t\tif (empty($charset))","\t\t{","\t\t\t// Use this in case mb_detect_charset isn't installed/loaded on this machine.","\t\t\t$charset = false;","\t\t\tif (function_exists('mb_detect_encoding'))","\t\t\t{","\t\t\t\t// Have php try to detect the encoding from the text given to us.","\t\t\t\t$charset = mb_detect_encoding($this->root->plaintext . \"ascii\", $encoding_list = array( \"UTF-8\", \"CP1252\" ) );","\t\t\t\tif (is_object($debug_object)) {$debug_object->debug_log(2, 'mb_detect found: ' . $charset);}","\t\t\t}","","\t\t\t// and if this doesn't work...  then we need to just wrongheadedly assume it's UTF-8 so that we can move on - cause this will usually give us most of what we need...","\t\t\tif ($charset === false)","\t\t\t{","\t\t\t\tif (is_object($debug_object)) {$debug_object->debug_log(2, 'since mb_detect failed - using default of utf-8');}","\t\t\t\t$charset = 'UTF-8';","\t\t\t}","\t\t}","","\t\t// Since CP1252 is a superset, if we get one of it's subsets, we want it instead.","\t\tif ((strtolower($charset) == strtolower('ISO-8859-1')) || (strtolower($charset) == strtolower('Latin1')) || (strtolower($charset) == strtolower('Latin-1')))","\t\t{","\t\t\tif (is_object($debug_object)) {$debug_object->debug_log(2, 'replacing ' . $charset . ' with CP1252 as its a superset');}","\t\t\t$charset = 'CP1252';","\t\t}","","\t\tif (is_object($debug_object)) {$debug_object->debug_log(1, 'EXIT - ' . $charset);}","","\t\treturn $this->_charset = $charset;","\t}","","\t// read tag info","\tprotected function read_tag()","\t{","\t\tif ($this->char!=='<')","\t\t{","\t\t\t$this->root->_[HDOM_INFO_END] = $this->cursor;","\t\t\treturn false;","\t\t}","\t\t$begin_tag_pos = $this->pos;","\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","","\t\t// end tag","\t\tif ($this->char==='/')","\t\t{","\t\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\t\t// This represents the change in the simple_html_dom trunk from revision 180 to 181.","\t\t\t// $this->skip($this->token_blank_t);","\t\t\t$this->skip($this->token_blank);","\t\t\t$tag = $this->copy_until_char('>');","","\t\t\t// skip attributes in end tag","\t\t\tif (($pos = strpos($tag, ' '))!==false)","\t\t\t\t$tag = substr($tag, 0, $pos);","","\t\t\t$parent_lower = strtolower($this->parent->tag);","\t\t\t$tag_lower = strtolower($tag);","","\t\t\tif ($parent_lower!==$tag_lower)","\t\t\t{","\t\t\t\tif (isset($this->optional_closing_tags[$parent_lower]) && isset($this->block_tags[$tag_lower]))","\t\t\t\t{","\t\t\t\t\t$this->parent->_[HDOM_INFO_END] = 0;","\t\t\t\t\t$org_parent = $this->parent;","","\t\t\t\t\twhile (($this->parent->parent) && strtolower($this->parent->tag)!==$tag_lower)","\t\t\t\t\t\t$this->parent = $this->parent->parent;","","\t\t\t\t\tif (strtolower($this->parent->tag)!==$tag_lower) {","\t\t\t\t\t\t$this->parent = $org_parent; // restore origonal parent","\t\t\t\t\t\tif ($this->parent->parent) $this->parent = $this->parent->parent;","\t\t\t\t\t\t$this->parent->_[HDOM_INFO_END] = $this->cursor;","\t\t\t\t\t\treturn $this->as_text_node($tag);","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\telse if (($this->parent->parent) && isset($this->block_tags[$tag_lower]))","\t\t\t\t{","\t\t\t\t\t$this->parent->_[HDOM_INFO_END] = 0;","\t\t\t\t\t$org_parent = $this->parent;","","\t\t\t\t\twhile (($this->parent->parent) && strtolower($this->parent->tag)!==$tag_lower)","\t\t\t\t\t\t$this->parent = $this->parent->parent;","","\t\t\t\t\tif (strtolower($this->parent->tag)!==$tag_lower)","\t\t\t\t\t{","\t\t\t\t\t\t$this->parent = $org_parent; // restore origonal parent","\t\t\t\t\t\t$this->parent->_[HDOM_INFO_END] = $this->cursor;","\t\t\t\t\t\treturn $this->as_text_node($tag);","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\telse if (($this->parent->parent) && strtolower($this->parent->parent->tag)===$tag_lower)","\t\t\t\t{","\t\t\t\t\t$this->parent->_[HDOM_INFO_END] = 0;","\t\t\t\t\t$this->parent = $this->parent->parent;","\t\t\t\t}","\t\t\t\telse","\t\t\t\t\treturn $this->as_text_node($tag);","\t\t\t}","","\t\t\t$this->parent->_[HDOM_INFO_END] = $this->cursor;","\t\t\tif ($this->parent->parent) $this->parent = $this->parent->parent;","","\t\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\t\treturn true;","\t\t}","","\t\t$node = new simple_html_dom_node($this);","\t\t$node->_[HDOM_INFO_BEGIN] = $this->cursor;","\t\t++$this->cursor;","\t\t$tag = $this->copy_until($this->token_slash);","\t\t$node->tag_start = $begin_tag_pos;","","\t\t// doctype, cdata & comments...","\t\tif (isset($tag[0]) && $tag[0]==='!') {","\t\t\t$node->_[HDOM_INFO_TEXT] = '<' . $tag . $this->copy_until_char('>');","","\t\t\tif (isset($tag[2]) && $tag[1]==='-' && $tag[2]==='-') {","\t\t\t\t$node->nodetype = HDOM_TYPE_COMMENT;","\t\t\t\t$node->tag = 'comment';","\t\t\t} else {","\t\t\t\t$node->nodetype = HDOM_TYPE_UNKNOWN;","\t\t\t\t$node->tag = 'unknown';","\t\t\t}","\t\t\tif ($this->char==='>') $node->_[HDOM_INFO_TEXT].='>';","\t\t\t$this->link_nodes($node, true);","\t\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\t\treturn true;","\t\t}","","\t\t// text","\t\tif ($pos=strpos($tag, '<')!==false) {","\t\t\t$tag = '<' . substr($tag, 0, -1);","\t\t\t$node->_[HDOM_INFO_TEXT] = $tag;","\t\t\t$this->link_nodes($node, false);","\t\t\t$this->char = $this->doc[--$this->pos]; // prev","\t\t\treturn true;","\t\t}","","\t\tif (!preg_match(\"/^[\\w-:]+$/\", $tag)) {","\t\t\t$node->_[HDOM_INFO_TEXT] = '<' . $tag . $this->copy_until('<>');","\t\t\tif ($this->char==='<') {","\t\t\t\t$this->link_nodes($node, false);","\t\t\t\treturn true;","\t\t\t}","","\t\t\tif ($this->char==='>') $node->_[HDOM_INFO_TEXT].='>';","\t\t\t$this->link_nodes($node, false);","\t\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\t\treturn true;","\t\t}","","\t\t// begin tag","\t\t$node->nodetype = HDOM_TYPE_ELEMENT;","\t\t$tag_lower = strtolower($tag);","\t\t$node->tag = ($this->lowercase) ? $tag_lower : $tag;","","\t\t// handle optional closing tags","\t\tif (isset($this->optional_closing_tags[$tag_lower]) )","\t\t{","\t\t\twhile (isset($this->optional_closing_tags[$tag_lower][strtolower($this->parent->tag)]))","\t\t\t{","\t\t\t\t$this->parent->_[HDOM_INFO_END] = 0;","\t\t\t\t$this->parent = $this->parent->parent;","\t\t\t}","\t\t\t$node->parent = $this->parent;","\t\t}","","\t\t$guard = 0; // prevent infinity loop","\t\t$space = array($this->copy_skip($this->token_blank), '', '');","","\t\t// attributes","\t\tdo","\t\t{","\t\t\tif ($this->char!==null && $space[0]==='')","\t\t\t{","\t\t\t\tbreak;","\t\t\t}","\t\t\t$name = $this->copy_until($this->token_equal);","\t\t\tif ($guard===$this->pos)","\t\t\t{","\t\t\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\t\t\tcontinue;","\t\t\t}","\t\t\t$guard = $this->pos;","","\t\t\t// handle endless '<'","\t\t\tif ($this->pos>=$this->size-1 && $this->char!=='>') {","\t\t\t\t$node->nodetype = HDOM_TYPE_TEXT;","\t\t\t\t$node->_[HDOM_INFO_END] = 0;","\t\t\t\t$node->_[HDOM_INFO_TEXT] = '<'.$tag . $space[0] . $name;","\t\t\t\t$node->tag = 'text';","\t\t\t\t$this->link_nodes($node, false);","\t\t\t\treturn true;","\t\t\t}","","\t\t\t// handle mismatch '<'","\t\t\tif ($this->doc[$this->pos-1]=='<') {","\t\t\t\t$node->nodetype = HDOM_TYPE_TEXT;","\t\t\t\t$node->tag = 'text';","\t\t\t\t$node->attr = array();","\t\t\t\t$node->_[HDOM_INFO_END] = 0;","\t\t\t\t$node->_[HDOM_INFO_TEXT] = substr($this->doc, $begin_tag_pos, $this->pos-$begin_tag_pos-1);","\t\t\t\t$this->pos -= 2;","\t\t\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\t\t\t$this->link_nodes($node, false);","\t\t\t\treturn true;","\t\t\t}","","\t\t\tif ($name!=='/' && $name!=='') {","\t\t\t\t$space[1] = $this->copy_skip($this->token_blank);","\t\t\t\t$name = $this->restore_noise($name);","\t\t\t\tif ($this->lowercase) $name = strtolower($name);","\t\t\t\tif ($this->char==='=') {","\t\t\t\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\t\t\t\t$this->parse_attr($node, $name, $space);","\t\t\t\t}","\t\t\t\telse {","\t\t\t\t\t//no value attr: nowrap, checked selected...","\t\t\t\t\t$node->_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_NO;","\t\t\t\t\t$node->attr[$name] = true;","\t\t\t\t\tif ($this->char!='>') $this->char = $this->doc[--$this->pos]; // prev","\t\t\t\t}","\t\t\t\t$node->_[HDOM_INFO_SPACE][] = $space;","\t\t\t\t$space = array($this->copy_skip($this->token_blank), '', '');","\t\t\t}","\t\t\telse","\t\t\t\tbreak;","\t\t} while ($this->char!=='>' && $this->char!=='/');","","\t\t$this->link_nodes($node, true);","\t\t$node->_[HDOM_INFO_ENDSPACE] = $space[0];","","\t\t// check self closing","\t\tif ($this->copy_until_char_escape('>')==='/')","\t\t{","\t\t\t$node->_[HDOM_INFO_ENDSPACE] .= '/';","\t\t\t$node->_[HDOM_INFO_END] = 0;","\t\t}","\t\telse","\t\t{","\t\t\t// reset parent","\t\t\tif (!isset($this->self_closing_tags[strtolower($node->tag)])) $this->parent = $node;","\t\t}","\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","","\t\t// If it's a BR tag, we need to set it's text to the default text.","\t\t// This way when we see it in plaintext, we can generate formatting that the user wants.","\t\t// since a br tag never has sub nodes, this works well.","\t\tif ($node->tag == \"br\")","\t\t{","\t\t\t$node->_[HDOM_INFO_INNER] = $this->default_br_text;","\t\t}","","\t\treturn true;","\t}","","\t// parse attributes","\tprotected function parse_attr($node, $name, &$space)","\t{","\t\t// Per sourceforge: http://sourceforge.net/tracker/?func=detail&aid=3061408&group_id=218559&atid=1044037","\t\t// If the attribute is already defined inside a tag, only pay atetntion to the first one as opposed to the last one.","\t\tif (isset($node->attr[$name]))","\t\t{","\t\t\treturn;","\t\t}","","\t\t$space[2] = $this->copy_skip($this->token_blank);","\t\tswitch ($this->char) {","\t\t\tcase '\"':","\t\t\t\t$node->_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_DOUBLE;","\t\t\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\t\t\t$node->attr[$name] = $this->restore_noise($this->copy_until_char_escape('\"'));","\t\t\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\t\t\tbreak;","\t\t\tcase '\\'':","\t\t\t\t$node->_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_SINGLE;","\t\t\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\t\t\t$node->attr[$name] = $this->restore_noise($this->copy_until_char_escape('\\''));","\t\t\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\t\t\tbreak;","\t\t\tdefault:","\t\t\t\t$node->_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_NO;","\t\t\t\t$node->attr[$name] = $this->restore_noise($this->copy_until($this->token_attr));","\t\t}","\t\t// PaperG: Attributes should not have \\r or \\n in them, that counts as html whitespace.","\t\t$node->attr[$name] = str_replace(\"\\r\", \"\", $node->attr[$name]);","\t\t$node->attr[$name] = str_replace(\"\\n\", \"\", $node->attr[$name]);","\t\t// PaperG: If this is a \"class\" selector, lets get rid of the preceeding and trailing space since some people leave it in the multi class case.","\t\tif ($name == \"class\") {","\t\t\t$node->attr[$name] = trim($node->attr[$name]);","\t\t}","\t}","","\t// link node's parent","\tprotected function link_nodes(&$node, $is_child)","\t{","\t\t$node->parent = $this->parent;","\t\t$this->parent->nodes[] = $node;","\t\tif ($is_child)","\t\t{","\t\t\t$this->parent->children[] = $node;","\t\t}","\t}","","\t// as a text node","\tprotected function as_text_node($tag)","\t{","\t\t$node = new simple_html_dom_node($this);","\t\t++$this->cursor;","\t\t$node->_[HDOM_INFO_TEXT] = '</' . $tag . '>';","\t\t$this->link_nodes($node, false);","\t\t$this->char = (++$this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\treturn true;","\t}","","\tprotected function skip($chars)","\t{","\t\t$this->pos += strspn($this->doc, $chars, $this->pos);","\t\t$this->char = ($this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t}","","\tprotected function copy_skip($chars)","\t{","\t\t$pos = $this->pos;","\t\t$len = strspn($this->doc, $chars, $pos);","\t\t$this->pos += $len;","\t\t$this->char = ($this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\tif ($len===0) return '';","\t\treturn substr($this->doc, $pos, $len);","\t}","","\tprotected function copy_until($chars)","\t{","\t\t$pos = $this->pos;","\t\t$len = strcspn($this->doc, $chars, $pos);","\t\t$this->pos += $len;","\t\t$this->char = ($this->pos<$this->size) ? $this->doc[$this->pos] : null; // next","\t\treturn substr($this->doc, $pos, $len);","\t}","","\tprotected function copy_until_char($char)","\t{","\t\tif ($this->char===null) return '';","","\t\tif (($pos = strpos($this->doc, $char, $this->pos))===false) {","\t\t\t$ret = substr($this->doc, $this->pos, $this->size-$this->pos);","\t\t\t$this->char = null;","\t\t\t$this->pos = $this->size;","\t\t\treturn $ret;","\t\t}","","\t\tif ($pos===$this->pos) return '';","\t\t$pos_old = $this->pos;","\t\t$this->char = $this->doc[$pos];","\t\t$this->pos = $pos;","\t\treturn substr($this->doc, $pos_old, $pos-$pos_old);","\t}","","\tprotected function copy_until_char_escape($char)","\t{","\t\tif ($this->char===null) return '';","","\t\t$start = $this->pos;","\t\twhile (1)","\t\t{","\t\t\tif (($pos = strpos($this->doc, $char, $start))===false)","\t\t\t{","\t\t\t\t$ret = substr($this->doc, $this->pos, $this->size-$this->pos);","\t\t\t\t$this->char = null;","\t\t\t\t$this->pos = $this->size;","\t\t\t\treturn $ret;","\t\t\t}","","\t\t\tif ($pos===$this->pos) return '';","","\t\t\tif ($this->doc[$pos-1]==='\\\\') {","\t\t\t\t$start = $pos+1;","\t\t\t\tcontinue;","\t\t\t}","","\t\t\t$pos_old = $this->pos;","\t\t\t$this->char = $this->doc[$pos];","\t\t\t$this->pos = $pos;","\t\t\treturn substr($this->doc, $pos_old, $pos-$pos_old);","\t\t}","\t}","","\t// remove noise from html content","\t// save the noise in the $this->noise array.","\tprotected function remove_noise($pattern, $remove_tag=false)","\t{","\t\tglobal $debug_object;","\t\tif (is_object($debug_object)) { $debug_object->debug_log_entry(1); }","","\t\t$count = preg_match_all($pattern, $this->doc, $matches, PREG_SET_ORDER|PREG_OFFSET_CAPTURE);","","\t\tfor ($i=$count-1; $i>-1; --$i)","\t\t{","\t\t\t$key = '___noise___'.sprintf('% 5d', count($this->noise)+1000);","\t\t\tif (is_object($debug_object)) { $debug_object->debug_log(2, 'key is: ' . $key); }","\t\t\t$idx = ($remove_tag) ? 0 : 1;","\t\t\t$this->noise[$key] = $matches[$i][$idx][0];","\t\t\t$this->doc = substr_replace($this->doc, $key, $matches[$i][$idx][1], strlen($matches[$i][$idx][0]));","\t\t}","","\t\t// reset the length of content","\t\t$this->size = strlen($this->doc);","\t\tif ($this->size>0)","\t\t{","\t\t\t$this->char = $this->doc[0];","\t\t}","\t}","","\t// restore noise to html content","\tfunction restore_noise($text)","\t{","\t\tglobal $debug_object;","\t\tif (is_object($debug_object)) { $debug_object->debug_log_entry(1); }","","\t\twhile (($pos=strpos($text, '___noise___'))!==false)","\t\t{","\t\t\t// Sometimes there is a broken piece of markup, and we don't GET the pos+11 etc... token which indicates a problem outside of us...","\t\t\tif (strlen($text) > $pos+15)","\t\t\t{","\t\t\t\t$key = '___noise___'.$text[$pos+11].$text[$pos+12].$text[$pos+13].$text[$pos+14].$text[$pos+15];","\t\t\t\tif (is_object($debug_object)) { $debug_object->debug_log(2, 'located key of: ' . $key); }","","\t\t\t\tif (isset($this->noise[$key]))","\t\t\t\t{","\t\t\t\t\t$text = substr($text, 0, $pos).$this->noise[$key].substr($text, $pos+16);","\t\t\t\t}","\t\t\t\telse","\t\t\t\t{","\t\t\t\t\t// do this to prevent an infinite loop.","\t\t\t\t\t$text = substr($text, 0, $pos).'UNDEFINED NOISE FOR KEY: '.$key . substr($text, $pos+16);","\t\t\t\t}","\t\t\t}","\t\t\telse","\t\t\t{","\t\t\t\t// There is no valid key being given back to us... We must get rid of the ___noise___ or we will have a problem.","\t\t\t\t$text = substr($text, 0, $pos).'NO NUMERIC NOISE KEY' . substr($text, $pos+11);","\t\t\t}","\t\t}","\t\treturn $text;","\t}","","\t// Sometimes we NEED one of the noise elements.","\tfunction search_noise($text)","\t{","\t\tglobal $debug_object;","\t\tif (is_object($debug_object)) { $debug_object->debug_log_entry(1); }","","\t\tforeach($this->noise as $noiseElement)","\t\t{","\t\t\tif (strpos($noiseElement, $text)!==false)","\t\t\t{","\t\t\t\treturn $noiseElement;","\t\t\t}","\t\t}","\t}","\tfunction __toString()","\t{","\t\treturn $this->root->innertext();","\t}","","\tfunction __get($name)","\t{","\t\tswitch ($name)","\t\t{","\t\t\tcase 'outertext':","\t\t\t\treturn $this->root->innertext();","\t\t\tcase 'innertext':","\t\t\t\treturn $this->root->innertext();","\t\t\tcase 'plaintext':","\t\t\t\treturn $this->root->text();","\t\t\tcase 'charset':","\t\t\t\treturn $this->_charset;","\t\t\tcase 'target_charset':","\t\t\t\treturn $this->_target_charset;","\t\t}","\t}","","\t// camel naming conventions","\tfunction childNodes($idx=-1) {return $this->root->childNodes($idx);}","\tfunction firstChild() {return $this->root->first_child();}","\tfunction lastChild() {return $this->root->last_child();}","\tfunction createElement($name, $value=null) {return @str_get_html(\"<$name>$value</$name>\")->first_child();}","\tfunction createTextNode($value) {return @end(str_get_html($value)->nodes);}","\tfunction getElementById($id) {return $this->find(\"#$id\", 0);}","\tfunction getElementsById($id, $idx=null) {return $this->find(\"#$id\", $idx);}","\tfunction getElementByTagName($name) {return $this->find($name, 0);}","\tfunction getElementsByTagName($name, $idx=-1) {return $this->find($name, $idx);}","\tfunction loadFile() {$args = func_get_args();$this->load_file($args);}","}","","?>"],"id":1}]]},"ace":{"folds":[],"scrolltop":27262,"scrollleft":0,"selection":{"start":{"row":1741,"column":2},"end":{"row":1741,"column":2},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":1702,"state":"php-start","mode":"ace/mode/php"}},"timestamp":1510955562917,"hash":"b593f39e83b0c8917dcf59e45b552df03743a070"}